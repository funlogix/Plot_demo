<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Product Sales Line Chart</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
    }
    .control-bar {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    select, input[type="month"] {
      margin: 0.5rem;
      padding: 0.3rem;
      font-size: 12px;
    }
    button {
      padding: 6px 10px;
      font-size: 12px;
    }
    #chart {
      margin-top: 2rem;
      background-color: #fff;
    }
  </style>

  <!-- UMD libraries via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.12/dist/html-to-image.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.10/dist/plot.umd.min.js"></script>

  <!-- Your local tooltip libraries (UMD assumed) -->
  <!-- <script src="./libs/htmlTooltip.js"></script> -->
  <script src="./libs/simplePlotTooltip.umd.js"></script>
</head>

<body>
  <h2>Monthly Sales Overview</h2>
  <div class="control-bar">
    <label>Select Product(s):</label><br />
    <select id="productSelect" multiple size="6"></select><br />

    <label>Select Date Range:</label><br />
    <input type="month" id="startDate" />
    <input type="month" id="endDate" /><br />

    <button id="exportPNG">Export as PNG</button>
    <button id="exportPDF">Export as PDF</button>
    <button id="exportSVG">Export as SVG</button>
  </div>
  <div id="chart"></div>

  <script>
    const plot = window.Plot;
    const jsPDF = window.jspdf.jsPDF;
    const htmlToImage = window.htmlToImage;
    const attachSimpleTooltip = window.SimplePlotTooltip.attachSimpleTooltip;
    

    async function loadCSV(path) {
      const response = await fetch(path);
      const text = await response.text();
      const rows = text.trim().split('\n');
      const headers = rows.shift().split(',');
      return rows.map(row => {
        const cols = row.split(',');
        const obj = {};
        headers.forEach((h, i) => {
          obj[h.trim()] = cols[i].trim();
        });
        return obj;
      });
    }

    function parseMonth(str) {
      const [month, day, year] = str.split('/');
      return new Date(`${year}-${month.padStart(2, '0')}-01`);
    }

    function patchAndExportChart2({ targetId = "chart", filename = "plot-export", format = "png" }) {
      const node = document.getElementById(targetId);
      if (!node) return console.warn("Chart container not found.");

      const clone = node.cloneNode(true);
      clone.style.backgroundColor = "#fff";
      clone.style.display = "inline-block";
      clone.style.padding = "0";
      clone.style.margin = "0";
      clone.style.border = "none";
      clone.style.boxSizing = "content-box";

      clone.querySelectorAll("svg").forEach(svg => {
        svg.style.overflow = "visible";
      });

      document.body.appendChild(clone);

      htmlToImage.toCanvas(clone, {
        pixelRatio: 2,
        backgroundColor: "#fff"
      }).then(canvas => {
        const dataUrl = canvas.toDataURL("image/png");

        if (format === "pdf") {
          const pdf = new jsPDF({
            orientation: "landscape",
            unit: "pt",
            format: [canvas.width, canvas.height]
          });
          pdf.addImage(dataUrl, "PNG", 0, 0, canvas.width, canvas.height);
          pdf.save(filename.endsWith(".pdf") ? filename : `${filename}.pdf`);
        } else {
          const link = document.createElement("a");
          link.download = filename.endsWith(".png") ? filename : `${filename}.png`;
          link.href = dataUrl;
          link.click();
        }

        document.body.removeChild(clone);
      }).catch(err => {
        console.error(`${format.toUpperCase()} export failed:`, err);
        document.body.removeChild(clone);
      });
    }


    function exportToSVG({
      targetId = "myPlotDiv",
      filename = "plot-export"
    }) {
      const container = document.getElementById(targetId);
      if (!container) return console.warn("Chart container not found.");

      // Clone the container to avoid modifying the original
      const clone = container.cloneNode(true);
      clone.style.backgroundColor = "#fff";
      clone.style.display = "inline-block";
      clone.style.padding = "0";
      clone.style.margin = "0";
      clone.style.border = "none";
      clone.style.boxSizing = "content-box";

      document.body.appendChild(clone);

      // Get bounding box of the entire container
      const rect = clone.getBoundingClientRect();
      const width = Math.ceil(rect.width);
      const height = Math.ceil(rect.height);

      // Create SVG wrapper with foreignObject
      const svgWrapper = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svgWrapper.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      svgWrapper.setAttribute("width", width);
      svgWrapper.setAttribute("height", height);

      const foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
      foreignObject.setAttribute("width", "100%");
      foreignObject.setAttribute("height", "100%");

      // Apply styles to ensure fonts and layout are preserved
      const style = document.createElement("style");
      style.textContent = `
        svg, div {
          font-family: sans-serif;
          font-size: 12px;
          color: #000;
        }
      `;

      // Wrap clone in a div to preserve layout
      const wrapperDiv = document.createElement("div");
      wrapperDiv.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
      wrapperDiv.appendChild(style);
      wrapperDiv.appendChild(clone);

      foreignObject.appendChild(wrapperDiv);
      svgWrapper.appendChild(foreignObject);

      // Serialize and export
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(svgWrapper);
      const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.download = filename.endsWith(".svg") ? filename : `${filename}.svg`;
      link.href = url;
      link.click();

      // Cleanup
      URL.revokeObjectURL(url);
      document.body.removeChild(clone);
    }

    function updateChart(data) {
      const selectedProducts = Array.from(document.getElementById("productSelect").selectedOptions).map(opt => opt.value);
      const startDate = new Date(document.getElementById("startDate").value + "-01");
      const endDate = new Date(document.getElementById("endDate").value + "-01");

      const filtered = data.filter(d =>
        selectedProducts.includes(d["product name"]) &&
        parseMonth(d["month/year"]) >= startDate &&
        parseMonth(d["month/year"]) <= endDate
      );

      const plotData = filtered.map(d => ({
        date: parseMonth(d["month/year"]),
        product: d["product name"],
        sales: parseFloat(d["sales amount"])
      }));

      if (plotData.length === 0) {
        document.getElementById("chart").innerHTML = "<p>No data available for selected filters.</p>";
        return;
      }

      const chart = plot.plot({
        marks: [
          plot.line(plotData, {
            x: "date",
            y: "sales",
            stroke: "product"
          }),
          plot.dot(plotData, {
            x: "date",
            y: "sales",
            r: 3,
            fillOpacity: 0.6,
            stroke: "product"
          })
        ],
        width: 800,
        height: 500,
        marginLeft: 50,
        color: { legend: true },
        x: { label: "Date" },
        y: { label: "Sales Amount ($)" }
      });

      if (detachTooltip) detachTooltip();

      document.getElementById("chart").replaceChildren(chart);

      detachTooltip = attachSimpleTooltip(chart, plotData, {
        x: d => d.date,
        y: d => d.sales,
        hitRadius: 18,
        text: d => `${fmtYM.format(d.date)} â€¢ ${d.product}: $${d.sales.toFixed(2)}`
      });
    }

    let detachTooltip;
    const fmtYM = new Intl.DateTimeFormat('en', { month: 'short', year: 'numeric' });

    (async () => {
      const data = await loadCSV("sales_data.csv");

      const products = [...new Set(data.map(d => d["product name"]))];
      const select = document.getElementById("productSelect");
      products.forEach(prod => {
        const option = document.createElement("option");
        option.value = prod;
        option.textContent = prod;
        select.appendChild(option);
      });

      const dates = [...new Set(data.map(d => parseMonth(d["month/year"])))].sort((a, b) => a - b);
      document.getElementById("startDate").value = dates[0].toISOString().slice(0, 7);
      document.getElementById("endDate").value = dates[dates.length - 1].toISOString().slice(0, 7);

      // Preselect first two products
      select.options[0].selected = true;
      if (select.options[1]) select.options[1].selected = true;

      console.log("Tooltip module:", window.simplePlotTooltip);
    console.log("Function:", window.simplePlotTooltip?.attachSimpleTooltip);

      updateChart(data);

      document.getElementById("exportPNG").onclick = () =>
        patchAndExportChart2({ targetId: "chart", filename: "sales-chart", format: "png" });

      document.getElementById("exportPDF").onclick = () =>
        patchAndExportChart2({ targetId: "chart", filename: "sales-chart", format: "pdf" });

      document.getElementById("exportSVG").onclick = () =>
        exportToSVG({ targetId: "chart", filename: "sales-chart"});

      document.getElementById("productSelect").addEventListener("change", () => updateChart(data));
      document.getElementById("startDate").addEventListener("change", () => updateChart(data));
      document.getElementById("endDate").addEventListener("change", () => updateChart(data));
    })();
  </script>
</body>
</html>
